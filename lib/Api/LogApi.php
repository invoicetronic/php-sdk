<?php
/**
 * LogApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Invoicetronic
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Italian eInvoice API v1
 *
 * The [Italian eInvoice API][2] is a RESTful API that allows you to send and receive invoices through the Italian [Servizio di Interscambio (SDI)][1], or Interchange Service. The API is designed by Invoicetronic to be simple and easy to use, abstracting away SDI complexity while providing complete control over the invoice send/receive process. The API also provides advanced features as encryption at rest, invoice validation, multiple upload formats, webhooks, event logging, client SDKs for commonly used languages, and CLI tools.  For more information, see  [Invoicetronic website][2]  [1]: https://www.fatturapa.gov.it/it/sistemainterscambio/cose-il-sdi/ [2]: https://invoicetronic.com/
 *
 * The version of the OpenAPI document: 1
 * Contact: support@invoicetronic.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Invoicetronic\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Invoicetronic\ApiException;
use Invoicetronic\Configuration;
use Invoicetronic\HeaderSelector;
use Invoicetronic\ObjectSerializer;

/**
 * LogApi Class Doc Comment
 *
 * @category Class
 * @package  Invoicetronic
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class LogApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'logGet' => [
            'application/json',
        ],
        'logIdGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation logGet
     *
     * List events
     *
     * @param  int|null $company_id Company id (optional)
     * @param  string|null $endpoint endpoint (optional)
     * @param  string|null $method method (optional)
     * @param  int|null $api_verion Api version (optional)
     * @param  int|null $status_code Response status code (optional)
     * @param  \DateTime|null $date_created_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime|null $date_created_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  int|null $page Page number. Defaults to 1. (optional, default to 1)
     * @param  int|null $page_size Items per page. Defaults to 50. Cannot be greater than 200. (optional, default to 100)
     * @param  string|null $sort Sort by field. Prefix with &#39;-&#39; for descending order. (optional)
     * @param  string|null $query query (optional)
     * @param  bool|null $success success (optional)
     * @param  \DateTime|null $date_time_from Date and time of the event (optional)
     * @param  \DateTime|null $date_time_to Date and time of the event (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['logGet'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Invoicetronic\Model\Event[]|\Invoicetronic\Model\ProblemHttpResult
     */
    public function logGet($company_id = null, $endpoint = null, $method = null, $api_verion = null, $status_code = null, $date_created_from = null, $date_created_to = null, $page = 1, $page_size = 100, $sort = null, $query = null, $success = null, $date_time_from = null, $date_time_to = null, string $contentType = self::contentTypes['logGet'][0])
    {
        list($response) = $this->logGetWithHttpInfo($company_id, $endpoint, $method, $api_verion, $status_code, $date_created_from, $date_created_to, $page, $page_size, $sort, $query, $success, $date_time_from, $date_time_to, $contentType);
        return $response;
    }

    /**
     * Operation logGetWithHttpInfo
     *
     * List events
     *
     * @param  int|null $company_id Company id (optional)
     * @param  string|null $endpoint (optional)
     * @param  string|null $method (optional)
     * @param  int|null $api_verion Api version (optional)
     * @param  int|null $status_code Response status code (optional)
     * @param  \DateTime|null $date_created_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime|null $date_created_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  int|null $page Page number. Defaults to 1. (optional, default to 1)
     * @param  int|null $page_size Items per page. Defaults to 50. Cannot be greater than 200. (optional, default to 100)
     * @param  string|null $sort Sort by field. Prefix with &#39;-&#39; for descending order. (optional)
     * @param  string|null $query (optional)
     * @param  bool|null $success (optional)
     * @param  \DateTime|null $date_time_from Date and time of the event (optional)
     * @param  \DateTime|null $date_time_to Date and time of the event (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['logGet'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Invoicetronic\Model\Event[]|\Invoicetronic\Model\ProblemHttpResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function logGetWithHttpInfo($company_id = null, $endpoint = null, $method = null, $api_verion = null, $status_code = null, $date_created_from = null, $date_created_to = null, $page = 1, $page_size = 100, $sort = null, $query = null, $success = null, $date_time_from = null, $date_time_to = null, string $contentType = self::contentTypes['logGet'][0])
    {
        $request = $this->logGetRequest($company_id, $endpoint, $method, $api_verion, $status_code, $date_created_from, $date_created_to, $page, $page_size, $sort, $query, $success, $date_time_from, $date_time_to, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Invoicetronic\Model\Event[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\Event[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\Event[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Invoicetronic\Model\ProblemHttpResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\ProblemHttpResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\ProblemHttpResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Invoicetronic\Model\Event[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\Event[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\ProblemHttpResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation logGetAsync
     *
     * List events
     *
     * @param  int|null $company_id Company id (optional)
     * @param  string|null $endpoint (optional)
     * @param  string|null $method (optional)
     * @param  int|null $api_verion Api version (optional)
     * @param  int|null $status_code Response status code (optional)
     * @param  \DateTime|null $date_created_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime|null $date_created_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  int|null $page Page number. Defaults to 1. (optional, default to 1)
     * @param  int|null $page_size Items per page. Defaults to 50. Cannot be greater than 200. (optional, default to 100)
     * @param  string|null $sort Sort by field. Prefix with &#39;-&#39; for descending order. (optional)
     * @param  string|null $query (optional)
     * @param  bool|null $success (optional)
     * @param  \DateTime|null $date_time_from Date and time of the event (optional)
     * @param  \DateTime|null $date_time_to Date and time of the event (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['logGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function logGetAsync($company_id = null, $endpoint = null, $method = null, $api_verion = null, $status_code = null, $date_created_from = null, $date_created_to = null, $page = 1, $page_size = 100, $sort = null, $query = null, $success = null, $date_time_from = null, $date_time_to = null, string $contentType = self::contentTypes['logGet'][0])
    {
        return $this->logGetAsyncWithHttpInfo($company_id, $endpoint, $method, $api_verion, $status_code, $date_created_from, $date_created_to, $page, $page_size, $sort, $query, $success, $date_time_from, $date_time_to, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation logGetAsyncWithHttpInfo
     *
     * List events
     *
     * @param  int|null $company_id Company id (optional)
     * @param  string|null $endpoint (optional)
     * @param  string|null $method (optional)
     * @param  int|null $api_verion Api version (optional)
     * @param  int|null $status_code Response status code (optional)
     * @param  \DateTime|null $date_created_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime|null $date_created_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  int|null $page Page number. Defaults to 1. (optional, default to 1)
     * @param  int|null $page_size Items per page. Defaults to 50. Cannot be greater than 200. (optional, default to 100)
     * @param  string|null $sort Sort by field. Prefix with &#39;-&#39; for descending order. (optional)
     * @param  string|null $query (optional)
     * @param  bool|null $success (optional)
     * @param  \DateTime|null $date_time_from Date and time of the event (optional)
     * @param  \DateTime|null $date_time_to Date and time of the event (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['logGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function logGetAsyncWithHttpInfo($company_id = null, $endpoint = null, $method = null, $api_verion = null, $status_code = null, $date_created_from = null, $date_created_to = null, $page = 1, $page_size = 100, $sort = null, $query = null, $success = null, $date_time_from = null, $date_time_to = null, string $contentType = self::contentTypes['logGet'][0])
    {
        $returnType = '\Invoicetronic\Model\Event[]';
        $request = $this->logGetRequest($company_id, $endpoint, $method, $api_verion, $status_code, $date_created_from, $date_created_to, $page, $page_size, $sort, $query, $success, $date_time_from, $date_time_to, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'logGet'
     *
     * @param  int|null $company_id Company id (optional)
     * @param  string|null $endpoint (optional)
     * @param  string|null $method (optional)
     * @param  int|null $api_verion Api version (optional)
     * @param  int|null $status_code Response status code (optional)
     * @param  \DateTime|null $date_created_from UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  \DateTime|null $date_created_to UTC ISO 8601 (2024-11-29T12:34:56Z) (optional)
     * @param  int|null $page Page number. Defaults to 1. (optional, default to 1)
     * @param  int|null $page_size Items per page. Defaults to 50. Cannot be greater than 200. (optional, default to 100)
     * @param  string|null $sort Sort by field. Prefix with &#39;-&#39; for descending order. (optional)
     * @param  string|null $query (optional)
     * @param  bool|null $success (optional)
     * @param  \DateTime|null $date_time_from Date and time of the event (optional)
     * @param  \DateTime|null $date_time_to Date and time of the event (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['logGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function logGetRequest($company_id = null, $endpoint = null, $method = null, $api_verion = null, $status_code = null, $date_created_from = null, $date_created_to = null, $page = 1, $page_size = 100, $sort = null, $query = null, $success = null, $date_time_from = null, $date_time_to = null, string $contentType = self::contentTypes['logGet'][0])
    {
















        $resourcePath = '/log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company_id,
            'company_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endpoint,
            'endpoint', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $method,
            'method', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $api_verion,
            'api_verion', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_code,
            'status_code', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_created_from,
            'date_created_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_created_to,
            'date_created_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $success,
            'success', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_time_from,
            'date_time_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_time_to,
            'date_time_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation logIdGet
     *
     * Get an event by id
     *
     * @param  int $id Item id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['logIdGet'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Invoicetronic\Model\Event
     */
    public function logIdGet($id, string $contentType = self::contentTypes['logIdGet'][0])
    {
        list($response) = $this->logIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation logIdGetWithHttpInfo
     *
     * Get an event by id
     *
     * @param  int $id Item id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['logIdGet'] to see the possible values for this operation
     *
     * @throws \Invoicetronic\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Invoicetronic\Model\Event, HTTP status code, HTTP response headers (array of strings)
     */
    public function logIdGetWithHttpInfo($id, string $contentType = self::contentTypes['logIdGet'][0])
    {
        $request = $this->logIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Invoicetronic\Model\Event' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Invoicetronic\Model\Event' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Invoicetronic\Model\Event', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Invoicetronic\Model\Event';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Invoicetronic\Model\Event',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation logIdGetAsync
     *
     * Get an event by id
     *
     * @param  int $id Item id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['logIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function logIdGetAsync($id, string $contentType = self::contentTypes['logIdGet'][0])
    {
        return $this->logIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation logIdGetAsyncWithHttpInfo
     *
     * Get an event by id
     *
     * @param  int $id Item id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['logIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function logIdGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['logIdGet'][0])
    {
        $returnType = '\Invoicetronic\Model\Event';
        $request = $this->logIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'logIdGet'
     *
     * @param  int $id Item id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['logIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function logIdGetRequest($id, string $contentType = self::contentTypes['logIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling logIdGet'
            );
        }


        $resourcePath = '/log/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
